# 🚀 Deployment Guide

This guide covers various deployment strategies for the DediWarn disaster management system.

## Table of Contents

1. [Render.com Deployment (Recommended)](#rendercom-deployment)
2. [AWS Deployment](#aws-deployment)
3. [Docker Deployment](#docker-deployment)
4. [Manual VPS Deployment](#manual-vps-deployment)
5. [Environment Configuration](#environment-configuration)
6. [CI/CD Setup](#cicd-setup)
7. [Monitoring & Logging](#monitoring--logging)

## Render.com Deployment

Render.com provides an excellent platform for deploying full-stack applications with minimal configuration.

### Prerequisites
- GitHub repository with your code
- Render account (free tier available)
- Environment variables configured

### Step 1: Repository Setup

Ensure your `render.yaml` file is configured:

```yaml
services:
  # Backend Service
  - type: web
    name: dediwarn-backend
    env: node
    region: singapore
    plan: starter
    buildCommand: cd backend && npm ci && npm run build
    startCommand: cd backend && npm start
    envVars:
      - key: NODE_ENV
        value: production
      - key: PORT
        value: 3001
    autoDeploy: true
    
  # Frontend Service  
  - type: web
    name: dediwarn-frontend
    env: static
    region: singapore
    plan: starter
    buildCommand: cd frontend && npm ci && npm run build
    staticPublishPath: frontend/dist
    envVars:
      - key: VITE_API_BASE_URL
        fromService:
          type: web
          name: dediwarn-backend
          property: host
    autoDeploy: true

databases:
  # MongoDB Database
  - name: dediwarn-mongodb
    databaseName: dediwarn
    user: dediwarn_user
    region: singapore
    plan: starter
    
  # Redis Cache
  - name: dediwarn-redis
    region: singapore
    plan: starter
```

### Step 2: Environment Variables

Configure these environment variables in the Render dashboard:

**Backend Environment Variables:**
```
NODE_ENV=production
PORT=3001
MONGODB_URI=[Auto-generated by Render]
REDIS_URL=[Auto-generated by Render]
OPENWEATHER_API_KEY=your_openweather_key
USGS_API_URL=https://earthquake.usgs.gov/earthquakes/feed/v1.0
TWILIO_ACCOUNT_SID=your_twilio_sid
TWILIO_AUTH_TOKEN=your_twilio_token
TWILIO_PHONE_NUMBER=your_twilio_phone
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your_email@gmail.com
SMTP_PASS=your_app_password
JWT_SECRET=your_secure_jwt_secret
SESSION_SECRET=your_secure_session_secret
```

**Frontend Environment Variables:**
```
VITE_API_BASE_URL=https://your-backend-url.onrender.com
VITE_SOCKET_URL=https://your-backend-url.onrender.com
VITE_GOOGLE_MAPS_API_KEY=your_google_maps_key
```

### Step 3: Deploy

1. Connect your GitHub repository to Render
2. Create services based on your `render.yaml`
3. Set environment variables in the Render dashboard
4. Deploy and monitor the build logs

## AWS Deployment

### Architecture Overview

```
Internet Gateway
    │
Application Load Balancer
    │
┌─────────────────┬─────────────────┐
│   Frontend      │    Backend      │
│   (S3 + CF)     │   (ECS/Fargate) │
└─────────────────┴─────────────────┘
    │                     │
    └─────────────────────┼─────────────────────┐
                          │                     │
                    ┌──────────┐         ┌──────────┐
                    │   RDS    │         │ ElastiCache│
                    │(MongoDB) │         │  (Redis)   │
                    └──────────┘         └──────────┘
```

### Frontend Deployment (S3 + CloudFront)

1. **Build the frontend:**
   ```bash
   cd frontend
   npm run build
   ```

2. **Upload to S3:**
   ```bash
   aws s3 sync dist/ s3://your-frontend-bucket --delete
   ```

3. **CloudFront configuration:**
   ```json
   {
     "DefaultRootObject": "index.html",
     "ErrorPages": [
       {
         "ErrorCode": 404,
         "ResponseCode": 200,
         "ResponsePagePath": "/index.html"
       }
     ],
     "Origins": [
       {
         "DomainName": "your-frontend-bucket.s3.amazonaws.com",
         "Id": "S3Origin",
         "S3OriginConfig": {
           "OriginAccessIdentity": ""
         }
       }
     ]
   }
   ```

### Backend Deployment (ECS Fargate)

1. **Create Dockerfile:**
   ```dockerfile
   FROM node:18-alpine
   WORKDIR /app
   COPY package*.json ./
   RUN npm ci --only=production
   COPY . .
   RUN npm run build
   EXPOSE 3001
   CMD ["npm", "start"]
   ```

2. **Build and push to ECR:**
   ```bash
   aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin your-account.dkr.ecr.us-east-1.amazonaws.com
   docker build -t dediwarn-backend .
   docker tag dediwarn-backend:latest your-account.dkr.ecr.us-east-1.amazonaws.com/dediwarn-backend:latest
   docker push your-account.dkr.ecr.us-east-1.amazonaws.com/dediwarn-backend:latest
   ```

3. **ECS Task Definition:**
   ```json
   {
     "family": "dediwarn-backend",
     "networkMode": "awsvpc",
     "requiresCompatibilities": ["FARGATE"],
     "cpu": "256",
     "memory": "512",
     "executionRoleArn": "arn:aws:iam::account:role/ecsTaskExecutionRole",
     "containerDefinitions": [
       {
         "name": "dediwarn-backend",
         "image": "your-account.dkr.ecr.us-east-1.amazonaws.com/dediwarn-backend:latest",
         "portMappings": [
           {
             "containerPort": 3001,
             "protocol": "tcp"
           }
         ],
         "environment": [
           {
             "name": "NODE_ENV",
             "value": "production"
           }
         ],
         "secrets": [
           {
             "name": "MONGODB_URI",
             "valueFrom": "arn:aws:secretsmanager:region:account:secret:mongodb-uri"
           }
         ],
         "logConfiguration": {
           "logDriver": "awslogs",
           "options": {
             "awslogs-group": "/ecs/dediwarn-backend",
             "awslogs-region": "us-east-1",
             "awslogs-stream-prefix": "ecs"
           }
         }
       }
     ]
   }
   ```

## Docker Deployment

### Development Setup

1. **Create docker-compose.yml:**
   ```yaml
   version: '3.8'
   
   services:
     frontend:
       build:
         context: ./frontend
         dockerfile: Dockerfile
       ports:
         - "5173:5173"
       environment:
         - VITE_API_BASE_URL=http://localhost:3001
       depends_on:
         - backend
   
     backend:
       build:
         context: ./backend
         dockerfile: Dockerfile
       ports:
         - "3001:3001"
       environment:
         - NODE_ENV=development
         - PORT=3001
         - MONGODB_URI=mongodb://mongodb:27017/dediwarn
         - REDIS_URL=redis://redis:6379
       depends_on:
         - mongodb
         - redis
   
     mongodb:
       image: mongo:6.0
       ports:
         - "27017:27017"
       volumes:
         - mongodb_data:/data/db
       environment:
         - MONGO_INITDB_DATABASE=dediwarn
   
     redis:
       image: redis:7-alpine
       ports:
         - "6379:6379"
       volumes:
         - redis_data:/data
   
   volumes:
     mongodb_data:
     redis_data:
   ```

2. **Start the services:**
   ```bash
   docker-compose up -d
   ```

### Production Setup

1. **Frontend Dockerfile:**
   ```dockerfile
   # Build stage
   FROM node:18-alpine AS builder
   WORKDIR /app
   COPY package*.json ./
   RUN npm ci
   COPY . .
   RUN npm run build
   
   # Production stage
   FROM nginx:alpine
   COPY --from=builder /app/dist /usr/share/nginx/html
   COPY nginx.conf /etc/nginx/conf.d/default.conf
   EXPOSE 80
   CMD ["nginx", "-g", "daemon off;"]
   ```

2. **Backend Dockerfile:**
   ```dockerfile
   FROM node:18-alpine
   WORKDIR /app
   COPY package*.json ./
   RUN npm ci --only=production
   COPY . .
   RUN npm run build
   USER node
   EXPOSE 3001
   CMD ["npm", "start"]
   ```

## Manual VPS Deployment

### Prerequisites
- Ubuntu 20.04+ VPS
- Domain name with DNS configured
- SSL certificate (Let's Encrypt recommended)

### Step 1: Server Setup

```bash
# Update system
sudo apt update && sudo apt upgrade -y

# Install Node.js
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs

# Install PM2 for process management
sudo npm install -g pm2

# Install Nginx
sudo apt install nginx -y

# Install MongoDB
wget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc | sudo apt-key add -
echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/6.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-6.0.list
sudo apt-get update
sudo apt-get install -y mongodb-org

# Install Redis
sudo apt install redis-server -y
```

### Step 2: Application Deployment

```bash
# Clone repository
git clone https://github.com/ogdevsanskar/dediwarn.git
cd dediwarn

# Install dependencies
npm install
cd frontend && npm install && npm run build
cd ../backend && npm install && npm run build
```

### Step 3: PM2 Configuration

Create `ecosystem.config.js`:
```javascript
module.exports = {
  apps: [
    {
      name: 'dediwarn-backend',
      cwd: './backend',
      script: 'npm',
      args: 'start',
      env: {
        NODE_ENV: 'production',
        PORT: 3001
      },
      instances: 'max',
      exec_mode: 'cluster'
    }
  ]
};
```

Start the application:
```bash
pm2 start ecosystem.config.js
pm2 save
pm2 startup
```

### Step 4: Nginx Configuration

Create `/etc/nginx/sites-available/dediwarn`:
```nginx
server {
    listen 80;
    server_name your-domain.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com;

    ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;

    # Frontend
    location / {
        root /path/to/dediwarn/frontend/dist;
        try_files $uri $uri/ /index.html;
    }

    # Backend API
    location /api {
        proxy_pass http://localhost:3001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }

    # WebSocket
    location /socket.io {
        proxy_pass http://localhost:3001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

Enable the site:
```bash
sudo ln -s /etc/nginx/sites-available/dediwarn /etc/nginx/sites-enabled/
sudo nginx -t
sudo systemctl reload nginx
```

## Environment Configuration

### Development Environment
Create `.env.development`:
```env
NODE_ENV=development
PORT=3001
MONGODB_URI=mongodb://localhost:27017/dediwarn_dev
REDIS_URL=redis://localhost:6379
LOG_LEVEL=debug
```

### Production Environment
Create `.env.production`:
```env
NODE_ENV=production
PORT=3001
MONGODB_URI=mongodb://prod-server:27017/dediwarn
REDIS_URL=redis://prod-server:6379
LOG_LEVEL=info
RATE_LIMIT_ENABLED=true
CORS_ORIGIN=https://your-domain.com
```

## CI/CD Setup

### GitHub Actions Workflow

Create `.github/workflows/deploy.yml`:
```yaml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      - run: npm ci
      - run: npm run test:all
      - run: npm run lint:all

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v3
      - name: Deploy to Render
        uses: render-deploy/github-action@v1.0.1
        with:
          service-id: ${{ secrets.RENDER_SERVICE_ID }}
          api-key: ${{ secrets.RENDER_API_KEY }}
```

### Deployment Script

Create `scripts/deploy.sh`:
```bash
#!/bin/bash
set -e

echo "🚀 Starting deployment..."

# Build applications
echo "📦 Building applications..."
npm run build:all

# Run tests
echo "🧪 Running tests..."
npm run test:all

# Deploy to production
echo "🌐 Deploying to production..."
if [ "$1" == "render" ]; then
    echo "Deploying to Render..."
    # Render auto-deploys on git push
    git push origin main
elif [ "$1" == "aws" ]; then
    echo "Deploying to AWS..."
    # AWS deployment commands
    ./scripts/deploy-aws.sh
else
    echo "Please specify deployment target: render or aws"
    exit 1
fi

echo "✅ Deployment completed successfully!"
```

## Monitoring & Logging

### Health Checks

Implement health check endpoints:
```javascript
// Backend health check
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    services: {
      database: dbHealth,
      redis: redisHealth,
      external_apis: apiHealth
    }
  });
});
```

### Logging Configuration

Use Winston for structured logging:
```javascript
const winston = require('winston');

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});
```

### Monitoring Setup

1. **Application Performance Monitoring (APM)**
   - New Relic
   - DataDog
   - Application Insights

2. **Log Aggregation**
   - ELK Stack (Elasticsearch, Logstash, Kibana)
   - Splunk
   - CloudWatch Logs

3. **Uptime Monitoring**
   - Pingdom
   - UptimeRobot
   - StatusPage

## Security Considerations

### SSL/TLS Configuration
```nginx
# Strong SSL configuration
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
ssl_prefer_server_ciphers off;
ssl_session_cache shared:SSL:10m;
ssl_session_timeout 10m;
add_header Strict-Transport-Security "max-age=63072000" always;
add_header X-Frame-Options DENY always;
add_header X-Content-Type-Options nosniff always;
add_header X-XSS-Protection "1; mode=block" always;
```

### Environment Security
- Use environment variables for secrets
- Implement proper CORS policies
- Enable rate limiting
- Use HTTPS in production
- Regular security updates

## Troubleshooting

### Common Issues

1. **Build Failures**
   ```bash
   # Clear node modules and reinstall
   rm -rf node_modules package-lock.json
   npm install
   ```

2. **Database Connection Issues**
   ```bash
   # Check MongoDB status
   sudo systemctl status mongod
   
   # Check Redis status
   sudo systemctl status redis
   ```

3. **Port Conflicts**
   ```bash
   # Check what's using a port
   sudo lsof -i :3001
   
   # Kill process using port
   sudo kill -9 <PID>
   ```

4. **Memory Issues**
   ```bash
   # Check memory usage
   free -h
   
   # Check process memory
   ps aux --sort=-%mem | head
   ```

### Logs Location

- **PM2 Logs**: `~/.pm2/logs/`
- **Nginx Logs**: `/var/log/nginx/`
- **MongoDB Logs**: `/var/log/mongodb/`
- **Application Logs**: `./logs/`

For additional help, check our [troubleshooting guide](./TROUBLESHOOTING.md) or create an issue on GitHub.
